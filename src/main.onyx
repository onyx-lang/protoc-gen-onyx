#load "./../lib/packages"
#load "./protos/proto"

use core {*}
use protobuf
use protobuf.google.protobuf {
    FileDescriptorProto
    DescriptorProto
    FieldDescriptorProto
    EnumDescriptorProto
}

use protobuf.google.protobuf.compiler {
    CodeGeneratorRequest
    CodeGeneratorResponse
}

main :: () {
    data := do {
        use r := io.Reader.make(&stdio.stream)
        return r->read_all()
    }

    request := protobuf.unmarshal(data, CodeGeneratorRequest)!

    files := make([..] CodeGeneratorResponse.File)
    for& file in request.proto_file {
        generated_file := generate_file(file)
        files->push(generated_file)
    }

    include_file_content := make(dyn_str)
    for& file in files {
        include_file_content->append(tprintf("#load \"./{}\"\n", file.name!))
    }
    files->push(.{ name = "proto.onyx", content = include_file_content })

    response := protobuf.marshal(CodeGeneratorResponse.{
        supported_features = 1
        file = files
    })!

    io.stream_write(&stdio.stream, response)
}

generate_file :: (file: &FileDescriptorProto) -> CodeGeneratorResponse.File {
    name := tprintf("{}.onyx", file.name->expect("expected file to have a name"))

    content := make(dyn_str)

    content->append(tprintf("package protobuf.{}\n\n", file.package_ ?? "default"))
    content->append("use protobuf\n\n")

    for& msg in file.message_type {
        output_message_type(&content, msg, "", file.syntax ?? "proto2")
    }

    for& enum_type in file.enum_type {
        output_enum_type(&content, enum_type, "")
    }

    return .{
        name = name
        content = content
    }
}

output_message_type :: (content: &dyn_str, msg: &DescriptorProto, parent_type: str, syntax: str) {
    content->append("@protobuf.Message\n")

    if parent_type {
        content->append(parent_type)
        content->append(".")
    }
    content->append(msg.name!)
    content->append(" :: struct {\n")

    for& field, index in msg.field {
        type := field.type!
        content->append(tprintf("    @protobuf.Field.{{{}, {}}}\n", field.number!, cast(u32) type))

        content->append("    ")
        content->append(safe_field_name(field.name!))
        content->append(": ")

        label := field.label ?? FieldDescriptorProto.Label.LABEL_OPTIONAL
        switch label {
            case .LABEL_REPEATED {
                content->append("[..] ")
            }

            case .LABEL_OPTIONAL {
                if type == .TYPE_MESSAGE {
                    content->append("? ")
                    break
                }

                if syntax == "proto2" || syntax == "proto1" || (field.proto3_optional ?? false) {
                    content->append("? ")
                }
            }
        }

        content->append(switch type {
            case .TYPE_DOUBLE  => "f64"
            case .TYPE_FLOAT  => "f32"
            case .TYPE_INT64  => "i64"
            case .TYPE_UINT64  => "u64"
            case .TYPE_INT32  => "i32"
            case .TYPE_FIXED64  => "i64"
            case .TYPE_FIXED32  => "i32"
            case .TYPE_BOOL  => "bool"
            case .TYPE_STRING  => "str"
            case .TYPE_GROUP  => "oh_no_group_is_not_supported"
            case .TYPE_MESSAGE  => tprintf("protobuf{}", field.type_name!)
            case .TYPE_BYTES  => "[] u8"
            case .TYPE_UINT32  => "u32"
            case .TYPE_ENUM  => tprintf("protobuf{}", field.type_name!)
            case .TYPE_SFIXED32  => "i32"
            case .TYPE_SFIXED64  => "i64"
            case .TYPE_SINT32  => "i32"
            case .TYPE_SINT64  => "i64"
        })

        field.options |> .with([o] {
            if o.deprecated ?? false {
                content->append("  // deprecated")
            }
        })

        content->append("\n")
    }

    content->append("}\n\n")

    next_parent_type := do {
        if parent_type do return tprintf("{}.{}", parent_type, msg.name!)
        else do return msg.name!
    }

    for& inner_msg in msg.nested_type {
        output_message_type(content, inner_msg, next_parent_type, syntax)
    }

    for& inner_enum in msg.enum_type {
        output_enum_type(content, inner_enum, next_parent_type)
    }
}

output_enum_type :: (content: &dyn_str, enum_type: &EnumDescriptorProto, parent_type: str) {
    if parent_type {
        content->append(parent_type)
        content->append(".")
    }
    content->append(enum_type.name!)
    content->append(" :: enum {\n")

    for& value, index in enum_type.value {
        content->append("    ")
        content->append(value.name!)
        content->append(" :: ")
        content->append(tprintf("{}", value.number!))

        value.options |> .with([o] {
            if o.deprecated ?? false {
                content->append("  // deprecated")
            }
        })

        content->append("\n")
    }

    content->append("}\n\n")
}

safe_field_name :: (s: str) -> str {
    #persist
    keywords := str.[
        "while", "do",
        "for", "in",
        "switch", "case",
        "interface", "where", "as",
        "struct", "enum", "union",
        "package", "use",
        "cast", "sizeof", "typeof", "alignof"
    ]

    if Slice.contains(keywords, s) {
        return tprintf("{}_", s)
    }

    return s
}

